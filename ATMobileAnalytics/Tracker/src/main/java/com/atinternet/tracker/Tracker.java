/*
This SDK is licensed under the MIT license (MIT)
Copyright (c) 2015- Applied Technologies Internet SAS (registration number B 403 261 258 - Trade and Companies Register of Bordeaux â€“ France)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */
package com.atinternet.tracker;

import android.annotation.TargetApi;
import android.app.Application;
import android.content.SharedPreferences;
import android.os.Build;
import android.text.TextUtils;
import android.util.Log;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Wrapper class for tracking usage of your application
 */
public class Tracker {

    /**
     * Enum for different offline mode
     */
    public enum OfflineMode {
        /**
         * hits are never stored
         */
        never,
        /**
         * hits are stored if no connection available
         */
        required,
        /**
         * hits are always stored
         */
        always
    }

    /**
     * Enum for different identifier
     */
    public enum IdentifierType {
        /**
         * provided by OS which is device identifier
         */
        androidId,
        /**
         * provided by GoogleAds
         */
        advertisingId,
        /**
         * Generated by ATInternet and stored in application data
         */
        UUID
    }

    /**
     * Enum for different plugin
     */
    public enum PluginKey {
        tvtracking, nuggad
    }

    protected static WeakReference<android.content.Context> appContext;
    private static Thread.UncaughtExceptionHandler defaultCrashHandler;
    private static boolean isTrackerActivityLifeCycleEnabled = false;
    private static Storage storage;

    protected TrackerListener listener;
    private Dispatcher dispatcher;
    private Buffer buffer;
    private String internalUserId;
    protected Configuration configuration;
    private final LinkedHashMap<String, BusinessObject> businessObjects = new LinkedHashMap<>();

    private Screens screens;
    private Gestures gestures;
    private Event event;
    private Context context;
    private TVTracking tvTracking;
    private NuggAds nuggAds;
    private Offline offline;
    private CustomObjects customObjects;
    private IdentifiedVisitor identifiedVisitor;
    private Publishers publishers;
    private SelfPromotions selfPromotions;
    private Locations locations;
    private CustomVars customVars;
    private Orders orders;
    private Cart cart;
    private Aisles aisles;
    private Campaigns campaigns;
    private InternalSearches internalSearches;
    private DynamicScreens dynamicScreens;
    private CustomTreeStructures customTreeStructures;
    private Products products;
    private MediaPlayers mediaPlayers;

    Buffer getBuffer() {
        return buffer;
    }

    static Storage getStorage() {
        return storage;
    }

    LinkedHashMap<String, BusinessObject> getBusinessObjects() {
        return businessObjects;
    }

    Dispatcher getDispatcher() {
        return dispatcher;
    }

    static android.content.Context getAppContext() {
        return appContext.get();
    }

    static SharedPreferences getPreferences() {
        return appContext.get().getSharedPreferences(TrackerConfigurationKeys.PREFERENCES, android.content.Context.MODE_PRIVATE);
    }

    String getInternalUserId() {
        return internalUserId;
    }

    void setInternalUserId(String internalUserId) {
        this.internalUserId = internalUserId;
    }

    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    private void setTrackerActivityLifecycle() {
        isTrackerActivityLifeCycleEnabled = true;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH && appContext.get() instanceof Application) {
            ((Application) appContext.get()).registerActivityLifecycleCallbacks(new TrackerActivityLifeCycle(configuration));
        }
    }

    private void initTracker() {
        try {
            listener = null;
            defaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();
            storage = new Storage(appContext.get());
            storage.setOfflineMode(Tool.convertStringToOfflineMode((String) configuration.get(TrackerConfigurationKeys.OFFLINE_MODE)));
            buffer = new Buffer(this);
            dispatcher = new Dispatcher(this);
            if ((Boolean) configuration.get(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION) && !(Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler)) {
                Thread.setDefaultUncaughtExceptionHandler(new CrashDetectionHandler(appContext.get(), defaultCrashHandler));
            }
            getPreferences().edit().putBoolean(TrackerConfigurationKeys.CAMPAIGN_ADDED_KEY, false).apply();

            if (!isTrackerActivityLifeCycleEnabled) {
                setTrackerActivityLifecycle();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Tracker processSetParam(String key, Closure value) {
        // Check whether the parameter is not in read only mode
        if (!Lists.getReadOnlyParams().contains(key)) {
            buffer.getVolatileParams().put(key, new Param(key, value));
        } else {
            Tool.executeCallback(listener, Tool.CallbackType.warning, String.format("Param %s is read only. Value will not be updated", key));
        }

        return this;
    }

    private Tracker processSetParam(String key, Closure value, ParamOption newParamOptions) {
        // Check whether the parameter is not in read only mode
        if (!Lists.getReadOnlyParams().contains(key)) {
            Param newParam = new Param(key, value, newParamOptions);
            List<Closure> newValues = new ArrayList<>();

            if (newParam.isPersistent()) {
                if (newParamOptions.isAppend()) {
                    Param existingParam;
                    if ((existingParam = buffer.getPersistentParams().get(key)) != null) {
                        newValues = existingParam.getValues();
                    }
                    if ((existingParam = buffer.getVolatileParams().get(key)) != null) {
                        existingParam.getValues().add(value);
                    }
                } else {
                    buffer.getVolatileParams().remove(key);
                }
                newValues.add(value);
                newParam.setValues(newValues);
                buffer.getPersistentParams().put(key, newParam);
            } else {
                if (newParamOptions.isAppend()) {
                    Param existingParam;
                    if ((existingParam = buffer.getVolatileParams().get(key)) != null) {
                        newValues = existingParam.getValues();
                    } else if ((existingParam = buffer.getPersistentParams().get(key)) != null) {
                        newValues = new ArrayList<>(existingParam.getValues());
                    }
                }
                newValues.add(value);
                newParam.setValues(newValues);
                buffer.getVolatileParams().put(key, newParam);
            }
        } else {
            Tool.executeCallback(listener, Tool.CallbackType.warning, String.format("Param %s is read only. Value will not be updated", key));
        }

        return this;
    }

    Tracker setParam(String key, Closure value) {
        return processSetParam(key, value);
    }

    Tracker setParam(String key, Closure value, ParamOption options) {
        return processSetParam(key, value, options);
    }

    private void refreshConfigurationDependencies() {
        String identifierKey = String.valueOf(configuration.get(TrackerConfigurationKeys.IDENTIFIER));
        String offlineMode = String.valueOf(configuration.get(TrackerConfigurationKeys.OFFLINE_MODE));
        boolean enableCrashDetectionHandler = Boolean.parseBoolean(String.valueOf(configuration.get(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION)));

        if (!TextUtils.isEmpty(identifierKey)) {
            buffer.setIdentifierKey(identifierKey);
        }
        if (!TextUtils.isEmpty(offlineMode)) {
            storage.setOfflineMode(Tool.convertStringToOfflineMode(offlineMode));
        }

        if (enableCrashDetectionHandler) {
            if (!(Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler)) {
                Thread.setDefaultUncaughtExceptionHandler(new CrashDetectionHandler(appContext.get(), defaultCrashHandler));
            }
        } else {
            if (Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler) {
                Thread.setDefaultUncaughtExceptionHandler(defaultCrashHandler);
            }
        }
    }

    private Tracker handleNotClosureStringParameterSetting(String key, final Object value, final ParamOption... options) {
        Closure stringValue = new Closure() {
            @Override
            public String execute() {
                return Tool.convertToString(value, options.length > 0 ? options[0].getSeparator() : ",");
            }
        };
        if (options.length > 0) {
            return processSetParam(key, stringValue, options[0]);
        } else {
            return processSetParam(key, stringValue);
        }
    }

    private void dispatchObjects(ArrayList<BusinessObject> objects, ArrayList<BusinessObject> customObjects) {
        if (!objects.isEmpty()) {
            objects.addAll(customObjects);
            dispatcher.dispatch((BusinessObject[]) objects.toArray(new BusinessObject[objects.size()]));
            customObjects.clear();
            objects.clear();
        }
    }

    /**
     * Get the current tracker configuration
     *
     * @return the current tracker configuration
     */
    public Configuration getConfiguration() {
        return configuration;
    }

    /**
     * Get the current tracker listener
     *
     * @return the current tracker listener
     */
    public TrackerListener getListener() {
        return listener;
    }

    /**
     * Asynchronous method to get user ID
     *
     * @param callback UserIdCallback: Called when user ID is available
     */
    public void getUserId(final UserIdCallback callback) {
        TrackerQueue.getInstance().put(new Runnable() {
            @Override
            public void run() {
                if (callback != null) {
                    String userID = TechnicalContext.getUserId((String) configuration.get(TrackerConfigurationKeys.IDENTIFIER)).execute();
                    if ((Boolean) configuration.get(TrackerConfigurationKeys.HASH_USER_ID) && !doNotTrackEnabled()) {
                        callback.receiveUserId(Tool.SHA_256(userID));
                    } else {
                        callback.receiveUserId(userID);
                    }
                } else {
                    Tool.executeCallback(listener, Tool.CallbackType.warning, "Enabled to get user id");
                }
            }
        });
    }

    /**
     * Get user id (require one hit sent)
     *
     * @return the user ID
     */
    public String getUserIdSync() {
        if (internalUserId == null) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "User id must be set");
        }
        return internalUserId;
    }

    /**
     * Set a custom user Id
     *
     * @param value new userId value
     */
    public void setUserId(String value) {
        handleNotClosureStringParameterSetting(Hit.HitParam.UserId.stringValue(), value, new ParamOption().setPersistent(true));
    }

    /**
     * Get Screens instance
     *
     * @return Screens instance
     */
    public Screens Screens() {
        return screens == null ? (screens = new Screens(this)) : screens;
    }

    /**
     * Get Gestures instance
     *
     * @return Gestures instance
     */
    public Gestures Gestures() {
        return gestures == null ? (gestures = new Gestures(this)) : gestures;
    }

    /**
     * Get Event instance
     *
     * @return Event
     */
    Event Event() {
        return event == null ? (event = new Event(this)) : event;
    }

    /**
     * Get Offline instance
     *
     * @return Offline instance
     */
    public Offline Offline() {
        return offline == null ? (offline = new Offline(this)) : offline;
    }

    /**
     * Get Context instance
     *
     * @return Context instance
     */
    public Context Context() {
        return context == null ? (context = new Context(this)) : context;
    }

    /**
     * Get TVTracking instance
     *
     * @return TVTracking instance
     */
    public TVTracking TVTracking() {
        return tvTracking == null ? (tvTracking = new TVTracking(this)) : tvTracking;
    }

    /**
     * Get NuggAd instance
     *
     * @return NuggAd instance
     */
    public NuggAds NuggAds() {
        return nuggAds == null ? (nuggAds = new NuggAds(this)) : nuggAds;
    }

    /**
     * Get CustomObjects instance
     *
     * @return CustomObjects instance
     */
    public CustomObjects CustomObjects() {
        return customObjects == null ? (customObjects = new CustomObjects(this)) : customObjects;
    }

    /**
     * Get IdentifiedVisitor instance
     *
     * @return IdentifiedVisitor instance
     */
    public IdentifiedVisitor IdentifiedVisitor() {
        return identifiedVisitor == null ? (identifiedVisitor = new IdentifiedVisitor(this)) : identifiedVisitor;
    }

    /**
     * Get Publishers instance
     *
     * @return Publishers instance
     */
    public Publishers Publishers() {
        return publishers == null ? (publishers = new Publishers(this)) : publishers;
    }

    /**
     * Get SelfPromotions instance
     *
     * @return SelfPromotions instance
     */
    public SelfPromotions SelfPromotions() {
        return selfPromotions == null ? (selfPromotions = new SelfPromotions(this)) : selfPromotions;
    }

    /**
     * Get DynamicScreens instance
     *
     * @return DynamicScreens instance
     */
    public DynamicScreens DynamicScreens() {
        return dynamicScreens == null ? (dynamicScreens = new DynamicScreens(this)) : dynamicScreens;
    }

    /**
     * Get Products instance
     *
     * @return Products instance
     */
    public Products Products() {
        return products == null ? (products = new Products(this)) : products;
    }

    /**
     * Get Cart instance
     *
     * @return Cart instance
     */
    public Cart Cart() {
        return cart == null ? (cart = new Cart(this)) : cart;
    }

    /**
     * Get MediaPlayers instance
     *
     * @return MediaPlayers instance
     */
    public MediaPlayers Players() {
        return mediaPlayers == null ? (mediaPlayers = new MediaPlayers(this)) : mediaPlayers;
    }

    /**
     * Get Locations instance
     *
     * @return Locations instance
     * @deprecated Since 2.3.0, Location is now only available as a screen object property.
     */
    @Deprecated
    public Locations Locations() {
        return locations == null ? (locations = new Locations(this)) : locations;
    }

    /**
     * Get CustomVars instance
     *
     * @return CustomVars instance
     * @deprecated Since 2.3.0, CustomVars is now only available as a screen object property.
     */
    @Deprecated
    public CustomVars CustomVars() {
        return customVars == null ? (customVars = new CustomVars(this)) : customVars;
    }

    /**
     * Get Aisles instance
     *
     * @return Aisles instance
     * @deprecated Since 2.3.0, Aisles is now only available as a screen object property.
     */
    @Deprecated
    public Aisles Aisles() {
        return aisles == null ? (aisles = new Aisles(this)) : aisles;
    }

    /**
     * Get Campaigns instance
     *
     * @return Campaigns instance
     */
    public Campaigns Campaigns() {
        return campaigns == null ? (campaigns = new Campaigns(this)) : campaigns;
    }

    /**
     * Get CustomTreeStructures instance
     *
     * @return CustomTreeStructures instance
     * @deprecated Since 2.3.0, CustomTreeStructure is now only available as a screen object property.
     */
    @Deprecated
    public CustomTreeStructures CustomTreeStructures() {
        return customTreeStructures == null ? (customTreeStructures = new CustomTreeStructures(this)) : customTreeStructures;
    }

    /**
     * Get InternalSearches instance
     *
     * @return InternalSearches instance
     * @deprecated Since 2.3.0, InternalSearch is now only available as a screen or gesture object property.
     */
    @Deprecated
    public InternalSearches InternalSearches() {
        return internalSearches == null ? (internalSearches = new InternalSearches(this)) : internalSearches;
    }

    /**
     * Get Orders instance
     *
     * @return Orders instance
     */
    public Orders Orders() {
        return orders == null ? (orders = new Orders(this)) : orders;
    }

    /**
     * Set a new log
     *
     * @param log               ATInternet subdomain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setLog(String log, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(log)) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for log, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.LOG, log, setConfigCallback, sync);
        }
    }

    /**
     * Set a new secured log
     *
     * @param securedLog        ATInternet secured subdomain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSecuredLog(String securedLog, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(securedLog)) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for secured log, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.LOG_SSL, securedLog, setConfigCallback, sync);
        }
    }

    /**
     * Set a new domain
     *
     * @param domain            ATInternet collect domain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setDomain(String domain, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(domain)) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for domain, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.DOMAIN, domain, setConfigCallback, sync);
        }
    }

    /**
     * Set a new siteId
     *
     * @param siteId            ATInternet site identifier
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSiteId(int siteId, SetConfigCallback setConfigCallback, boolean... sync) {
        if (siteId <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for site id, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.SITE, siteId, setConfigCallback, sync);
        }
    }

    /**
     * Set a new offline mode
     *
     * @param offlineMode       /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setOfflineMode(OfflineMode offlineMode, SetConfigCallback setConfigCallback, boolean... sync) {
        if (offlineMode == null) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for offline mode, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.OFFLINE_MODE, offlineMode.toString(), setConfigCallback, sync);
        }
    }

    /**
     * Enable secure mode (use HTTPS with secured log)
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSecureModeEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.SECURE, enabled, setConfigCallback, sync);
    }

    /**
     * Set a new identifier type
     *
     * @param identifierType    /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setIdentifierType(IdentifierType identifierType, SetConfigCallback setConfigCallback, boolean... sync) {
        if (identifierType == null) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for identifier type, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.IDENTIFIER, identifierType.toString(), setConfigCallback, sync);
        }
    }

    /**
     * Enable hash user id (SHA-256 with salt to ensure anonymity)
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setHashUserIdEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.HASH_USER_ID, enabled, setConfigCallback, sync);
    }

    /**
     * Set new plugins
     *
     * @param plugins           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPlugins(List<PluginKey> plugins, SetConfigCallback setConfigCallback, boolean... sync) {
        if (plugins == null) {
            setConfig(TrackerConfigurationKeys.PLUGINS, "", setConfigCallback, sync);
        } else {
            String value = "";
            boolean isFirst = true;
            for (PluginKey plugin : plugins) {
                if (isFirst) {
                    isFirst = false;
                } else {
                    value += ",";
                }
                value += plugin.toString();
            }
            setConfig(TrackerConfigurationKeys.PLUGINS, value, setConfigCallback, sync);
        }
    }

    /**
     * Set new pixel path
     *
     * @param pixelPath         request path to get pixel
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPixelPath(String pixelPath, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(pixelPath)) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for pixel path, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.PIXEL_PATH, pixelPath, setConfigCallback, sync);
        }
    }

    /**
     * Enable persistent identified visitor (identification data available for all sessions)
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPersistentIdentifiedVisitorEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.PERSIST_IDENTIFIED_VISITOR, enabled, setConfigCallback, sync);
    }

    /**
     * Set a new TVTracking url
     *
     * @param url               TVTracking campaign url
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setTvTrackingUrl(String url, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(url)) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for tv tracking url, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.TVTRACKING_URL, url, setConfigCallback, sync);
        }
    }

    /**
     * Set a new TVTracking visit duration
     *
     * @param visitDuration     duration of the visit
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setTvTrackingVisitDuration(int visitDuration, SetConfigCallback setConfigCallback, boolean... sync) {
        if (visitDuration <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for tv tracking visit duration, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.TVTRACKING_VISIT_DURATION, visitDuration, setConfigCallback, sync);
        }
    }

    /**
     * Set a new TVTracking spot validity time
     *
     * @param time              time during which campaign is valid
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setTvTrackingSpotValidityTime(int time, SetConfigCallback setConfigCallback, boolean... sync) {
        if (time <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for tv tracking spot validity time, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.TVTRACKING_SPOT_VALIDITY_TIME, time, setConfigCallback, sync);
        }
    }

    /**
     * Enable crash detection
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCrashDetectionEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION, enabled, setConfigCallback, sync);
    }

    /**
     * Enable last persistence campaign
     *
     * @param enabled           store last or first campaign
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCampaignLastPersistenceEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.CAMPAIGN_LAST_PERSISTENCE, enabled, setConfigCallback, sync);
    }

    /**
     * Set a new campaign lifetime
     *
     * @param lifetime          campaign lifetime
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCampaignLifetime(int lifetime, SetConfigCallback setConfigCallback, boolean... sync) {
        if (lifetime <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for campaign lifetime, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.CAMPAIGN_LIFETIME, lifetime, setConfigCallback, sync);
        }
    }

    /**
     * Set a new session background duration
     *
     * @param duration          duration between two application openings after which a new session is started
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSessionBackgroundDuration(int duration, SetConfigCallback setConfigCallback, boolean... sync) {
        if (duration <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.warning, "Bad value for session background duration, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.SESSION_BACKGROUND_DURATION, duration, setConfigCallback, sync);
        }
    }

    /**
     * Create a default listener
     *
     * @return tracker listener which log in console
     */
    public TrackerListener createDefaultTrackerListener() {
        return new TrackerListener() {
            @Override
            public void trackerNeedsFirstLaunchApproval(String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: First Launch \n\tMessage: " + message);
            }

            @Override
            public void buildDidEnd(HitStatus status, String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Building Hit \n\tStatus: " + status.toString() + "\n\tMessage: " + message);
            }

            @Override
            public void sendDidEnd(HitStatus status, String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Sending Hit \n\tStatus: " + status.toString() + "\n\tMessage: " + message);
            }

            @Override
            public void didCallPartner(String response) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Calling Partner \n\tResponse: " + response);
            }

            @Override
            public void warningDidOccur(String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Warning \n\tMessage: " + message);
            }

            @Override
            public void saveDidEnd(String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Saving Hit \n\tMessage: " + message);
            }

            @Override
            public void errorDidOccur(String message) {
                Log.d("ATINTERNET", "Debugging message: \n\tEvent: Error \n\tMessage: " + message);
            }
        };
    }

    /**
     * Set a new configuration
     *
     * @param conf              map that contains new keys/values
     * @param override          if true, old config fully cleared AND all default keys MUST be set
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     * @deprecated Since 2.3.5, override boolean parameter is useless, {@link #setConfig(HashMap, SetConfigCallback, boolean...)} instead.
     */
    @Deprecated
    public void setConfig(final HashMap<String, Object> conf, final boolean override, final SetConfigCallback setConfigCallback, boolean... sync) {
        if (sync.length == 1 && sync[0]) {
            if (override) {
                configuration.clear();
            }
            Set<String> keys = conf.keySet();
            for (String key : keys) {
                if (!Lists.getReadOnlyConfigs().contains(key)) {
                    configuration.put(key, conf.get(key));
                } else {
                    Tool.executeCallback(listener, Tool.CallbackType.warning, "Cannot to overwrite " + key + " configuration");
                }
            }
            refreshConfigurationDependencies();
        } else {
            TrackerQueue.getInstance().put(new Runnable() {
                @Override
                public void run() {
                    if (override) {
                        configuration.clear();
                    }
                    Set<String> keys = conf.keySet();
                    for (String key : keys) {
                        if (!Lists.getReadOnlyConfigs().contains(key)) {
                            configuration.put(key, conf.get(key));
                        } else {
                            Tool.executeCallback(listener, Tool.CallbackType.warning, "Cannot to overwrite " + key + " configuration");
                        }
                    }
                    refreshConfigurationDependencies();
                    if (setConfigCallback != null) {
                        setConfigCallback.setConfigEnd();
                    }
                }
            });
        }
    }

    /**
     * Set a new configuration
     *
     * @param conf              map that contains new keys/values
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setConfig(final HashMap<String, Object> conf, final SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(conf, false, setConfigCallback, sync);
    }

    /**
     * Set an only one new key/value pair
     *
     * @param key               /
     * @param value             /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setConfig(final String key, final Object value, final SetConfigCallback setConfigCallback, boolean... sync) {
        if (sync.length == 1 && sync[0]) {
            if (!Lists.getReadOnlyConfigs().contains(key)) {
                configuration.put(key, value);
                refreshConfigurationDependencies();
            } else {
                Tool.executeCallback(listener, Tool.CallbackType.warning, "Cannot to overwrite " + key + " configuration");
            }
        } else {
            TrackerQueue.getInstance().put(new Runnable() {
                @Override
                public void run() {
                    if (!Lists.getReadOnlyConfigs().contains(key)) {
                        configuration.put(key, value);
                        refreshConfigurationDependencies();
                        if (setConfigCallback != null) {
                            setConfigCallback.setConfigEnd();
                        }
                    } else {
                        Tool.executeCallback(listener, Tool.CallbackType.warning, "Cannot to overwrite " + key + " configuration");
                    }
                }
            });
        }
    }

    /**
     * Set a new listener
     *
     * @param trackerListener /
     * @return Tracker instance
     */
    public Tracker setListener(TrackerListener trackerListener) {
        this.listener = trackerListener;
        if (getPreferences().getBoolean(LifeCycle.FIRST_SESSION, false)) {
            listener.trackerNeedsFirstLaunchApproval("Tracker First Launch");
        }
        return this;
    }

    /**
     * Set a default tracker listener (see createDefaultTrackerListener method)
     *
     * @return Tracker instance
     */
    public Tracker setDefaultListener() {
        this.listener = createDefaultTrackerListener();
        if (getPreferences().getBoolean(LifeCycle.FIRST_SESSION, false)) {
            listener.trackerNeedsFirstLaunchApproval("Tracker First Launch");
        }
        return this;
    }

    /**
     * Initialisation with default configuration
     */
    public Tracker() {
        try {
            android.content.Context context = ((Application) Class.forName("android.app.ActivityThread")
                    .getMethod("currentApplication").invoke(null, (Object[]) null));
            appContext = new WeakReference<>(context);
            configuration = new Configuration(appContext.get());
            initTracker();
            if (!LifeCycle.isInitialized) {
                LifeCycle.initLifeCycle(appContext.get());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Initialisation with default configuration
     *
     * @param context the current Activity context
     */
    public Tracker(android.content.Context context) {
        appContext = new WeakReference<>(context.getApplicationContext());
        configuration = new Configuration(appContext.get());
        initTracker();
        if (!LifeCycle.isInitialized) {
            LifeCycle.initLifeCycle(appContext.get());
        }
    }

    /**
     * Initialisation with a custom configuration
     *
     * @param configuration map that contains new keys/values see TrackerConfigurationKeys
     */
    public Tracker(final HashMap<String, Object> configuration) {
        android.content.Context context;
        try {
            context = ((Application) Class.forName("android.app.ActivityThread")
                    .getMethod("currentApplication").invoke(null, (Object[]) null));
            appContext = new WeakReference<>(context);
            this.configuration = new Configuration(configuration);
            initTracker();
            if (!LifeCycle.isInitialized) {
                LifeCycle.initLifeCycle(appContext.get());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Initialisation with a custom configuration
     *
     * @param context       the current Activity context
     * @param configuration map that contains new keys/values see TrackerConfigurationKeys
     */
    public Tracker(android.content.Context context, final HashMap<String, Object> configuration) {
        appContext = new WeakReference<>(context.getApplicationContext());
        this.configuration = new Configuration(configuration);
        initTracker();
        if (!LifeCycle.isInitialized) {
            LifeCycle.initLifeCycle(appContext.get());
        }
    }

    /**
     * Disable user identification
     *
     * @param enabled /
     */
    public static void doNotTrack(final boolean enabled) {
        TrackerQueue.getInstance().put(new Runnable() {
            @Override
            public void run() {
                TechnicalContext.doNotTrack(appContext.get(), enabled);
            }
        });
    }

    /**
     * Get "doNotTrack" value
     *
     * @return true if "doNotTrack" is enabled
     */
    public static boolean doNotTrackEnabled() {
        return TechnicalContext.doNotTrackEnabled(appContext.get());
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value integer value
     * @return Tracker instance
     */
    public Tracker setParam(String key, int value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   integer value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, int value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value float value
     * @return Tracker instance
     */
    public Tracker setParam(String key, float value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   float value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, float value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value double value
     * @return Tracker instance
     */
    public Tracker setParam(String key, double value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   double value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, double value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value boolean value
     * @return Tracker instance
     */
    public Tracker setParam(String key, boolean value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   boolean value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, boolean value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value string value
     * @return Tracker instance
     */
    public Tracker setParam(String key, String value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   string value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, final String value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value list value
     * @return Tracker instance
     */
    public Tracker setParam(String key, List value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   list value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, List value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value object array value
     * @return Tracker instance
     */
    public Tracker setParam(String key, Object[] value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   object array value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, Object[] value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value map value
     * @return Tracker instance
     */
    public Tracker setParam(String key, Map value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   map value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, Map value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Remove a parameter from the hit querystring
     *
     * @param key parameter key to remove
     */
    public void unsetParam(String key) {
        buffer.getVolatileParams().remove(key);
        buffer.getPersistentParams().remove(key);
    }

    /**
     * Reset Screen context to prevent bad link between screen and gesture
     */
    public void resetScreenContext() {
        TechnicalContext.screenName = null;
        TechnicalContext.level2 = 0;
    }

    /**
     * Sends all tracking objects added
     */
    public void dispatch() {
        if (businessObjects.size() > 0) {
            ArrayList<BusinessObject> onAppAds = new ArrayList<>();
            ArrayList<BusinessObject> customObjects = new ArrayList<>();
            ArrayList<BusinessObject> objects = new ArrayList<BusinessObject>() {{
                addAll(businessObjects.values());
            }};
            ArrayList<BusinessObject> screenObjects = new ArrayList<>();
            ArrayList<BusinessObject> salesTrackerObjects = new ArrayList<>();
            ArrayList<BusinessObject> internalSearchObjects = new ArrayList<>();
            ArrayList<BusinessObject> productsObjects = new ArrayList<>();

            for (BusinessObject businessObject : objects) {

                if (!(businessObject instanceof Product)) {
                    dispatchObjects(productsObjects, customObjects);
                }

                // Dispatch onAppAds before sending other object
                if (!(businessObject instanceof OnAppAd || businessObject instanceof ScreenInfo || businessObject instanceof AbstractScreen || businessObject instanceof InternalSearch || businessObject instanceof Cart || businessObject instanceof Order)
                        || (businessObject instanceof OnAppAd && ((OnAppAd) businessObject).getAction() == OnAppAd.Action.Touch)) {
                    dispatchObjects(onAppAds, customObjects);
                }

                if (businessObject instanceof OnAppAd) {
                    OnAppAd ad = (OnAppAd) businessObject;
                    if (ad.getAction() == OnAppAd.Action.View) {
                        onAppAds.add(ad);
                    } else {
                        customObjects.add(businessObject);
                        dispatcher.dispatch((BusinessObject[]) customObjects.toArray(new BusinessObject[customObjects.size()]));
                        customObjects.clear();
                    }
                } else if (businessObject instanceof CustomObject || businessObject instanceof NuggAd) {
                    customObjects.add(businessObject);
                } else if (businessObject instanceof ScreenInfo) {
                    screenObjects.add(businessObject);
                } else if (businessObject instanceof InternalSearch) {
                    internalSearchObjects.add(businessObject);
                } else if (businessObject instanceof Product) {
                    productsObjects.add(businessObject);
                } else if (businessObject instanceof Order || businessObject instanceof Cart) {
                    salesTrackerObjects.add(businessObject);
                } else if (businessObject instanceof AbstractScreen) {
                    onAppAds.addAll(customObjects);
                    onAppAds.addAll(screenObjects);
                    onAppAds.addAll(internalSearchObjects);

                    //Sales tracker
                    ArrayList<BusinessObject> orders = new ArrayList<>();
                    Cart cart = null;

                    for (BusinessObject obj : salesTrackerObjects) {
                        if (obj instanceof Cart) {
                            cart = (Cart) obj;
                        } else {
                            orders.add(obj);
                        }
                    }

                    if (cart != null && (((AbstractScreen) businessObject).isBasketScreen() || !orders.isEmpty())) {
                        onAppAds.add(cart);
                    }

                    onAppAds.addAll(orders);
                    onAppAds.add(businessObject);
                    dispatcher.dispatch((BusinessObject[]) onAppAds.toArray(new BusinessObject[onAppAds.size()]));

                    screenObjects.clear();
                    salesTrackerObjects.clear();
                    internalSearchObjects.clear();
                    onAppAds.clear();
                    customObjects.clear();
                } else {
                    if (businessObject instanceof Gesture && ((Gesture) businessObject).getAction() == Gesture.Action.InternalSearch) {
                        onAppAds.addAll(internalSearchObjects);
                        internalSearchObjects.clear();
                    }
                    onAppAds.addAll(customObjects);
                    onAppAds.add(businessObject);
                    dispatcher.dispatch((BusinessObject[]) onAppAds.toArray(new BusinessObject[onAppAds.size()]));

                    onAppAds.clear();
                    customObjects.clear();
                }
            }

            dispatchObjects(onAppAds, customObjects);

            dispatchObjects(productsObjects, customObjects);

            if (!customObjects.isEmpty() || !screenObjects.isEmpty() || !internalSearchObjects.isEmpty()) {
                customObjects.addAll(screenObjects);
                customObjects.addAll(internalSearchObjects);
                dispatcher.dispatch((BusinessObject[]) customObjects.toArray(new BusinessObject[customObjects.size()]));

                customObjects.clear();
                screenObjects.clear();
                internalSearchObjects.clear();
            }
        } else {
            dispatcher.dispatch();
        }
    }
}
