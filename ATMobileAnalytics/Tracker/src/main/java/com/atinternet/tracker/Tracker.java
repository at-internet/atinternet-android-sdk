/*
 * This SDK is licensed under the MIT license (MIT)
 * Copyright (c) 2015- Applied Technologies Internet SAS (registration number B 403 261 258 - Trade and Companies Register of Bordeaux â€“ France)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package com.atinternet.tracker;

import android.annotation.TargetApi;
import android.app.Application;
import android.content.SharedPreferences;
import android.os.Build;
import android.text.TextUtils;
import android.util.Log;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

/**
 * Wrapper class for tracking usage of your application
 */
public class Tracker {

    /**
     * Enum for different offline mode
     */
    public enum OfflineMode {
        /**
         * hits are never stored
         */
        never,
        /**
         * hits are stored if no connection available
         */
        required,
        /**
         * hits are always stored
         */
        always
    }

    /**
     * Enum for different identifier
     */
    public enum IdentifierType {
        /**
         * provided by OS which is device identifier
         */
        androidId,
        /**
         * provided by GoogleAds or HuaweiAds
         */
        advertisingId,
        /**
         * Generated by ATInternet and stored in application data
         */
        UUID,
        /**
         * provided by GoogleAds
         */
        googleAdId,
        /**
         * provided by HuaweiAds
         */
        huaweiOAId,
    }

    /**
     * Enum for different UUID Expiration mode
     */
    public enum UUIDExpirationMode {
        fixed,
        relative,
    }

    /**
     * Enum for different Proxy type
     */
    public enum ProxyType {
        none,
        http,
        socks
    }

    /**
     * Enum for different plugin
     */
    public enum PluginKey {
        nuggad
    }

    private static boolean isTrackerActivityLifeCycleEnabled;

    private static WeakReference<android.content.Context> appContext;

    private Thread.UncaughtExceptionHandler defaultCrashHandler;
    private TrackerListener listener;
    private Dispatcher dispatcher;
    private Buffer buffer;
    private String internalUserId;
    protected Configuration configuration;
    private final LinkedHashMap<String, BusinessObject> businessObjects = new LinkedHashMap<>();

    private Screens screens;
    private Gestures gestures;
    private Events events;
    private Context context;
    private NuggAds nuggAds;
    private Offline offline;
    private CustomObjects customObjects;
    private IdentifiedVisitor identifiedVisitor;
    private Publishers publishers;
    private SelfPromotions selfPromotions;
    private Locations locations;
    private CustomVars customVars;
    private Orders orders;
    private Cart cart;
    private Aisles aisles;
    private Campaigns campaigns;
    private InternalSearches internalSearches;
    private DynamicScreens dynamicScreens;
    private CustomTreeStructures customTreeStructures;
    private Products products;
    private MediaPlayers mediaPlayers;
    private MvTestings mvTestings;
    private ECommerce eCommerce;
    private AVInsights avInsights;

    private String userAgent;
    private String applicationVersion;

    private void registerInstanceIfNeeded(boolean registerNeeded) {
        if (registerNeeded) {
            ATInternet.getInstance().registerTracker(UUID.randomUUID().toString(), this);
        }
    }

    /**
     * Initialisation with default configuration
     */
    public Tracker() {
        this(true);
    }

    Tracker(boolean registerNeeded) {
        try {
            android.content.Context ctx = ((Application) Class.forName("android.app.ActivityThread")
                    .getMethod("currentApplication").invoke(null, (Object[]) null));
            appContext = new WeakReference<>(ctx);
            configuration = new Configuration(appContext.get());
            initTracker();
            if (!LifeCycle.isInitialized) {
                LifeCycle.initLifeCycle(appContext.get());
            }

            registerInstanceIfNeeded(registerNeeded);
        } catch (Exception e) {
            Log.e(ATInternet.TAG, e.toString());
        }
    }

    /**
     * Initialisation with default configuration
     *
     * @param context the current Activity context
     */
    public Tracker(android.content.Context context) {
        this(context, true);
    }

    Tracker(android.content.Context context, boolean registerNeeded) {
        appContext = new WeakReference<>(context.getApplicationContext());
        configuration = new Configuration(appContext.get());
        initTracker();
        if (!LifeCycle.isInitialized) {
            LifeCycle.initLifeCycle(appContext.get());
        }
        registerInstanceIfNeeded(registerNeeded);
    }

    /**
     * Initialisation with a custom configuration
     *
     * @param configuration map that contains new keys/values see TrackerConfigurationKeys
     */
    public Tracker(final HashMap<String, Object> configuration) {
        this(configuration, true);
    }

    Tracker(final HashMap<String, Object> configuration, boolean registerNeeded) {
        android.content.Context context;
        try {
            context = ((Application) Class.forName("android.app.ActivityThread")
                    .getMethod("currentApplication").invoke(null, (Object[]) null));
            appContext = new WeakReference<>(context);
            this.configuration = new Configuration(configuration);
            initTracker();
            if (!LifeCycle.isInitialized) {
                LifeCycle.initLifeCycle(appContext.get());
            }
            registerInstanceIfNeeded(registerNeeded);
        } catch (Exception e) {
            Log.e(ATInternet.TAG, e.toString());
        }
    }

    /**
     * Initialisation with a custom configuration
     *
     * @param context       the current Activity context
     * @param configuration map that contains new keys/values see TrackerConfigurationKeys
     */
    public Tracker(android.content.Context context, final HashMap<String, Object> configuration) {
        this(context, configuration, true);
    }

    Tracker(android.content.Context context, final HashMap<String, Object> configuration, boolean registerNeeded) {
        appContext = new WeakReference<>(context.getApplicationContext());
        this.configuration = new Configuration(configuration);
        initTracker();
        if (!LifeCycle.isInitialized) {
            LifeCycle.initLifeCycle(appContext.get());
        }
        registerInstanceIfNeeded(registerNeeded);
    }

    Buffer getBuffer() {
        return buffer;
    }

    public LinkedHashMap<String, BusinessObject> getBusinessObjects() {
        return businessObjects;
    }

    Dispatcher getDispatcher() {
        return dispatcher;
    }

    static android.content.Context getAppContext() {
        return appContext.get();
    }

    static SharedPreferences getPreferences() {
        return appContext.get().getSharedPreferences(TrackerConfigurationKeys.PREFERENCES, android.content.Context.MODE_PRIVATE);
    }

    OfflineMode getOfflineMode() {
        return Tool.convertStringToOfflineMode((String) configuration.get(TrackerConfigurationKeys.OFFLINE_MODE));
    }

    void setInternalUserId(String internalUserId) {
        this.internalUserId = internalUserId;
    }

    @TargetApi(14)
    private void setTrackerActivityLifecycle() {
        isTrackerActivityLifeCycleEnabled = true;
        if (Build.VERSION.SDK_INT >= 14 && appContext.get() instanceof Application) {
            ((Application) appContext.get()).registerActivityLifecycleCallbacks(new TrackerActivityLifeCycle(configuration));
        }
    }

    private void initTracker() {
        try {
            listener = null;
            defaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();
            buffer = new Buffer(this);
            dispatcher = new Dispatcher(this);
            if ((boolean) configuration.get(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION) && !(Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler)) {
                Thread.setDefaultUncaughtExceptionHandler(new CrashDetectionHandler(appContext.get().getPackageName(), getPreferences(), defaultCrashHandler));
            }
            getPreferences().edit().putBoolean(TrackerConfigurationKeys.CAMPAIGN_ADDED_KEY, false).apply();

            if (!isTrackerActivityLifeCycleEnabled) {
                setTrackerActivityLifecycle();
            }
        } catch (Exception e) {
            Log.e(ATInternet.TAG, e.toString());
        }
    }

    private Tracker processSetParam(String key, Closure value) {
        // Check whether the parameter is not in read only mode
        if (Lists.getReadOnlyParams().contains(key)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, String.format("Param %s is read only. Value will not be updated", key));
            return this;
        }
        buffer.getVolatileParams().put(key, new Param(key, value));
        return this;
    }


    private Tracker processSetParam(String key, Closure value, ParamOption newParamOptions) {
        // Check whether the parameter is not in read only mode
        if (Lists.getReadOnlyParams().contains(key)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, String.format("Param %s is read only. Value will not be updated", key));
            return this;
        }

        Param newParam = new Param(key, value, newParamOptions);
        List<Closure> newValues = new ArrayList<>();

        if (newParam.isPersistent()) {
            if (newParamOptions.isAppend()) {
                Param existingParam;
                if ((existingParam = buffer.getPersistentParams().get(key)) != null) {
                    newValues = existingParam.getValues();
                    if (existingParam.getOptions() != null) {
                        newParam.getOptions().setType(existingParam.getOptions().getType());
                    }
                }
                if ((existingParam = buffer.getVolatileParams().get(key)) != null) {
                    existingParam.getValues().add(value);
                    if (existingParam.getOptions() != null) {
                        newParam.getOptions().setType(existingParam.getOptions().getType());
                    }
                }
            } else {
                buffer.getVolatileParams().remove(key);
            }
            newValues.add(value);
            newParam.setValues(newValues);
            buffer.getPersistentParams().put(key, newParam);
        } else {
            if (newParamOptions.isAppend()) {
                Param existingParam;
                if ((existingParam = buffer.getVolatileParams().get(key)) != null) {
                    newValues = existingParam.getValues();
                    if (existingParam.getOptions() != null) {
                        newParam.getOptions().setType(existingParam.getOptions().getType());
                    }
                } else if ((existingParam = buffer.getPersistentParams().get(key)) != null) {
                    newValues = new ArrayList<>(existingParam.getValues());
                    if (existingParam.getOptions() != null) {
                        newParam.getOptions().setType(existingParam.getOptions().getType());
                    }
                }
            }
            newValues.add(value);
            newParam.setValues(newValues);
            buffer.getVolatileParams().put(key, newParam);
        }

        return this;
    }

    Param getParam(String key) {
        Param p = buffer.getVolatileParams().get(key);
        if (p != null) {
            return p;
        }
        return buffer.getPersistentParams().get(key);
    }

    List<Param> getParams() {
        List<Param> params = new ArrayList<>();
        params.addAll(buffer.getVolatileParams().values());
        params.addAll(buffer.getPersistentParams().values());
        return params;
    }

    Tracker setParam(String key, Closure value) {
        return processSetParam(key, value);
    }

    Tracker setParam(String key, Closure value, ParamOption options) {
        return processSetParam(key, value, options);
    }

    private void refreshConfigurationDependencies() {
        String identifierKey = String.valueOf(configuration.get(TrackerConfigurationKeys.IDENTIFIER));
        boolean ignoreLimitedAdTracking = Boolean.parseBoolean(String.valueOf(configuration.get(TrackerConfigurationKeys.IGNORE_LIMITED_AD_TRACKING)));
        int uuidDuration = Integer.parseInt(String.valueOf(configuration.get(TrackerConfigurationKeys.UUID_DURATION)));
        String uuidExpirationMode = String.valueOf(configuration.get(TrackerConfigurationKeys.UUID_EXPIRATION_MODE));

        boolean enableCrashDetectionHandler = Boolean.parseBoolean(String.valueOf(configuration.get(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION)));

        if (!TextUtils.isEmpty(identifierKey)) {
            buffer.setIdentifierKey(identifierKey, ignoreLimitedAdTracking, uuidDuration, uuidExpirationMode);
        }

        if (enableCrashDetectionHandler) {
            if (!(Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler)) {
                Thread.setDefaultUncaughtExceptionHandler(new CrashDetectionHandler(appContext.get().getPackageName(), getPreferences(), defaultCrashHandler));
            }
        } else {
            if (Thread.getDefaultUncaughtExceptionHandler() instanceof CrashDetectionHandler) {
                Thread.setDefaultUncaughtExceptionHandler(defaultCrashHandler);
            }
        }
    }

    private Tracker handleNotClosureStringParameterSetting(String key, final Object value, final ParamOption... options) {
        Closure stringValue = new Closure() {
            @Override
            public String execute() {
                return Tool.convertToString(value, options.length > 0 ? options[0].getSeparator() : ",");
            }
        };
        if (options.length > 0) {
            return processSetParam(key, stringValue, options[0]);
        } else {
            return processSetParam(key, stringValue);
        }
    }

    private void dispatchObjects(ArrayList<BusinessObject> objects, ArrayList<BusinessObject> customObjects) {
        if (!objects.isEmpty()) {
            objects.addAll(customObjects);
            dispatcher.dispatch((BusinessObject[]) objects.toArray(new BusinessObject[objects.size()]));
            customObjects.clear();
            objects.clear();
        }
    }

    /**
     * Get the current tracker configuration
     *
     * @return the current tracker configuration
     */
    public Configuration getConfiguration() {
        return configuration;
    }

    /**
     * Get the current tracker listener
     *
     * @return the current tracker listener
     */
    public TrackerListener getListener() {
        return listener;
    }

    /**
     * Asynchronous method to get user ID
     *
     * @param callback UserIdCallback: Called when user ID is available
     */
    public void getUserId(final UserIdCallback callback) {
        TrackerQueue.getInstance().put(new Runnable() {
            @Override
            public void run() {
                if (callback != null) {
                    boolean ignoreLimitedAdTracking = Boolean.parseBoolean(String.valueOf(configuration.get(TrackerConfigurationKeys.IGNORE_LIMITED_AD_TRACKING)));
                    int uuidDuration = Integer.parseInt(String.valueOf(configuration.get(TrackerConfigurationKeys.UUID_DURATION)));
                    String uuidExpirationMode = String.valueOf(configuration.get(TrackerConfigurationKeys.UUID_EXPIRATION_MODE));

                    String userID = TechnicalContext.getUserId(String.valueOf(configuration.get(TrackerConfigurationKeys.IDENTIFIER)), ignoreLimitedAdTracking, uuidDuration, uuidExpirationMode).execute();
                    if ((boolean) configuration.get(TrackerConfigurationKeys.HASH_USER_ID) && !TechnicalContext.optOutEnabled(getAppContext())) {
                        callback.receiveUserId(Tool.sha256(userID));
                    } else {
                        callback.receiveUserId(userID);
                    }
                } else {
                    Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Enabled to get user id");
                }
            }
        });
    }

    /**
     * Get user id (require one hit sent)
     *
     * @return the user ID
     */
    public String getUserIdSync() {
        if (internalUserId == null) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "User id must be set");
        }
        return internalUserId;
    }

    /**
     * Set a custom user Id
     *
     * @param value new userId value
     */
    public void setUserId(String value) {
        handleNotClosureStringParameterSetting(Hit.HitParam.UserId.stringValue(), value, new ParamOption().setPersistent(true));
    }

    /**
     * Get Screens instance
     *
     * @return Screens instance
     */
    public Screens Screens() {
        if (screens == null) {
            screens = new Screens(this);
        }
        return screens;
    }

    /**
     * Get Gestures instance
     *
     * @return Gestures instance
     */
    public Gestures Gestures() {
        if (gestures == null) {
            gestures = new Gestures(this);
        }
        return gestures;
    }

    public Events Events() {
        if (events == null) {
            events = new Events(this);
        }
        return events;
    }

    public ECommerce ECommerce() {
        if (eCommerce == null) {
            eCommerce = new ECommerce(this);
        }
        return eCommerce;
    }

    public AVInsights AVInsights() {
        if (avInsights == null) {
            avInsights = new AVInsights(this);
        }
        return avInsights;
    }

    /**
     * Get Offline instance
     *
     * @return Offline instance
     */
    public Offline Offline() {
        if (offline == null) {
            offline = new Offline(this);
        }
        return offline;
    }

    /**
     * Get Context instance
     *
     * @return Context instance
     */
    public Context Context() {
        if (context == null) {
            context = new Context(this);
        }
        return context;
    }

    /**
     * Get NuggAd instance
     *
     * @return NuggAd instance
     */
    public NuggAds NuggAds() {
        if (nuggAds == null) {
            nuggAds = new NuggAds(this);
        }
        return nuggAds;
    }

    /**
     * Get CustomObjects instance
     *
     * @return CustomObjects instance
     */
    public CustomObjects CustomObjects() {
        if (customObjects == null) {
            customObjects = new CustomObjects(this);
        }
        return customObjects;
    }

    /**
     * Get IdentifiedVisitor instance
     *
     * @return IdentifiedVisitor instance
     */
    public IdentifiedVisitor IdentifiedVisitor() {
        if (identifiedVisitor == null) {
            identifiedVisitor = new IdentifiedVisitor(this);
        }
        return identifiedVisitor;
    }

    /**
     * Get Publishers instance
     *
     * @return Publishers instance
     */
    public Publishers Publishers() {
        if (publishers == null) {
            publishers = new Publishers(this);
        }
        return publishers;
    }

    /**
     * Get SelfPromotions instance
     *
     * @return SelfPromotions instance
     */
    public SelfPromotions SelfPromotions() {
        if (selfPromotions == null) {
            selfPromotions = new SelfPromotions(this);
        }
        return selfPromotions;
    }

    /**
     * Get DynamicScreens instance
     *
     * @return DynamicScreens instance
     */
    public DynamicScreens DynamicScreens() {
        if (dynamicScreens == null) {
            dynamicScreens = new DynamicScreens(this);
        }
        return dynamicScreens;
    }

    /**
     * Get Products instance
     *
     * @return Products instance
     */
    public Products Products() {
        if (products == null) {
            products = new Products(this);
        }
        return products;
    }

    /**
     * Get Cart instance
     *
     * @return Cart instance
     */
    public Cart Cart() {
        if (cart == null) {
            cart = new Cart(this);
        }
        return cart;
    }

    /**
     * Get MediaPlayers instance
     *
     * @return MediaPlayers instance
     */
    public MediaPlayers Players() {
        if (mediaPlayers == null) {
            mediaPlayers = new MediaPlayers(this);
        }
        return mediaPlayers;
    }

    /**
     * Get Locations instance
     *
     * @return Locations instance
     * @deprecated Since 2.3.0, Location is now only available as a screen object property.
     */
    @Deprecated
    public Locations Locations() {
        if (locations == null) {
            locations = new Locations(this);
        }
        return locations;
    }

    /**
     * Get CustomVars instance
     *
     * @return CustomVars instance
     * @deprecated Since 2.3.0, CustomVars is now only available as a screen object property.
     */
    @Deprecated
    public CustomVars CustomVars() {
        if (customVars == null) {
            customVars = new CustomVars(this);
        }
        return customVars;
    }

    /**
     * Get Aisles instance
     *
     * @return Aisles instance
     * @deprecated Since 2.3.0, Aisles is now only available as a screen object property.
     */
    @Deprecated
    public Aisles Aisles() {
        if (aisles == null) {
            aisles = new Aisles(this);
        }
        return aisles;
    }

    /**
     * Get Campaigns instance
     *
     * @return Campaigns instance
     */
    public Campaigns Campaigns() {
        if (campaigns == null) {
            campaigns = new Campaigns(this);
        }
        return campaigns;
    }

    /**
     * Get CustomTreeStructures instance
     *
     * @return CustomTreeStructures instance
     * @deprecated Since 2.3.0, CustomTreeStructure is now only available as a screen object property.
     */
    @Deprecated
    public CustomTreeStructures CustomTreeStructures() {
        if (customTreeStructures == null) {
            customTreeStructures = new CustomTreeStructures(this);
        }
        return customTreeStructures;
    }

    /**
     * Get InternalSearches instance
     *
     * @return InternalSearches instance
     * @deprecated Since 2.3.0, InternalSearch is now only available as a screen or gesture object property.
     */
    @Deprecated
    public InternalSearches InternalSearches() {
        if (internalSearches == null) {
            internalSearches = new InternalSearches(this);
        }
        return internalSearches;
    }

    /**
     * Get Orders instance
     *
     * @return Orders instance
     */
    public Orders Orders() {
        if (orders == null) {
            orders = new Orders(this);
        }
        return orders;
    }

    /**
     * Get MvTestings instance
     *
     * @return MvTestings instance
     */
    public MvTestings MvTestings() {
        if (mvTestings == null) {
            mvTestings = new MvTestings(this);
        }
        return mvTestings;
    }

    /**
     * Set a new log
     *
     * @param log               ATInternet subdomain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setLog(String log, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(log)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for log, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.LOG, log, setConfigCallback, sync);
        }
    }

    /**
     * Set a new secured log
     *
     * @param securedLog        ATInternet secured subdomain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSecuredLog(String securedLog, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(securedLog)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for secured log, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.LOG_SSL, securedLog, setConfigCallback, sync);
        }
    }

    /**
     * Set a new domain
     *
     * @param domain            ATInternet collect domain value
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setDomain(String domain, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(domain)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for domain, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.DOMAIN, domain, setConfigCallback, sync);
        }
    }

    /**
     * Set a new siteId
     *
     * @param siteId            ATInternet site identifier
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSiteId(int siteId, SetConfigCallback setConfigCallback, boolean... sync) {
        if (siteId <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for site id, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.SITE, siteId, setConfigCallback, sync);
        }
    }

    /**
     * Set a new offline mode
     *
     * @param offlineMode       /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setOfflineMode(OfflineMode offlineMode, SetConfigCallback setConfigCallback, boolean... sync) {
        if (offlineMode == null) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for offline mode, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.OFFLINE_MODE, offlineMode.toString(), setConfigCallback, sync);
        }
    }

    /**
     * Enable secure mode
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     * @deprecated Since 2.14.0, secure mode forced
     */
    @Deprecated
    public void setSecureModeEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Useless method, secure mode forced");
    }

    /**
     * Set a new identifier type
     *
     * @param identifierType    /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setIdentifierType(IdentifierType identifierType, SetConfigCallback setConfigCallback, boolean... sync) {
        if (identifierType == null) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for identifier type, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.IDENTIFIER, identifierType.toString(), setConfigCallback, sync);
        }
    }

    /**
     * Enable ignore limited ad tracking
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setIgnoreLimitedAdTrackingEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.IGNORE_LIMITED_AD_TRACKING, enabled, setConfigCallback, sync);
    }

    /**
     * Enable send hit when opt out
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSendHitWhenOptOutEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.SEND_HIT_WHEN_OPT_OUT, enabled, setConfigCallback, sync);
    }

    /**
     * Enable hash user id (SHA-256 with salt to ensure anonymity)
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setHashUserIdEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.HASH_USER_ID, enabled, setConfigCallback, sync);
    }

    /**
     * Set new plugins
     *
     * @param plugins           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPlugins(List<PluginKey> plugins, SetConfigCallback setConfigCallback, boolean... sync) {
        if (plugins == null) {
            setConfig(TrackerConfigurationKeys.PLUGINS, "", setConfigCallback, sync);
        } else {
            StringBuilder value = new StringBuilder();
            boolean isFirst = true;
            for (PluginKey plugin : plugins) {
                if (isFirst) {
                    isFirst = false;
                } else {
                    value.append(',');
                }
                value.append(plugin.toString());
            }
            setConfig(TrackerConfigurationKeys.PLUGINS, value.toString(), setConfigCallback, sync);
        }
    }

    /**
     * Set new pixel path
     *
     * @param pixelPath         request path to get pixel
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPixelPath(String pixelPath, SetConfigCallback setConfigCallback, boolean... sync) {
        if (TextUtils.isEmpty(pixelPath)) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for pixel path, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.PIXEL_PATH, pixelPath, setConfigCallback, sync);
        }
    }

    /**
     * Enable persistent identified visitor (identification data available for all sessions)
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setPersistentIdentifiedVisitorEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.PERSIST_IDENTIFIED_VISITOR, enabled, setConfigCallback, sync);
    }

    /**
     * Enable crash detection
     *
     * @param enabled           /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCrashDetectionEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.ENABLE_CRASH_DETECTION, enabled, setConfigCallback, sync);
    }

    /**
     * Enable last persistence campaign
     *
     * @param enabled           store last or first campaign
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCampaignLastPersistenceEnabled(boolean enabled, SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(TrackerConfigurationKeys.CAMPAIGN_LAST_PERSISTENCE, enabled, setConfigCallback, sync);
    }

    /**
     * Set a new campaign lifetime
     *
     * @param lifetime          campaign lifetime
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setCampaignLifetime(int lifetime, SetConfigCallback setConfigCallback, boolean... sync) {
        if (lifetime <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for campaign lifetime, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.CAMPAIGN_LIFETIME, lifetime, setConfigCallback, sync);
        }
    }

    /**
     * Set a new session background duration
     *
     * @param duration          duration between two application openings after which a new session is started
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setSessionBackgroundDuration(int duration, SetConfigCallback setConfigCallback, boolean... sync) {
        if (duration <= 0) {
            Tool.executeCallback(listener, Tool.CallbackType.WARNING, "Bad value for session background duration, default value retained");
        } else {
            setConfig(TrackerConfigurationKeys.SESSION_BACKGROUND_DURATION, duration, setConfigCallback, sync);
        }
    }

    /**
     * Set a new max hit size value
     *
     * @param maxHitSize int
     */
    public void setMaxHitSize(int maxHitSize) {
        if (maxHitSize < 1_600) {
            maxHitSize = 1_600;
        }
        configuration.put(TrackerConfigurationKeys.MAX_HIT_SIZE, maxHitSize);
    }

    /**
     * Set a new uuid duration
     *
     * @param uuidDuration int
     */
    public void setUUIDDuration(int uuidDuration) {
        setConfig(TrackerConfigurationKeys.UUID_DURATION, uuidDuration, null, true);
    }

    /**
     * Set a new proxy type
     *
     * @param proxyType ProxyType
     */
    public void setProxyType(ProxyType proxyType) {
        setConfig(TrackerConfigurationKeys.PROXY_TYPE, proxyType.toString(), null, true);
    }

    /**
     * Set a new proxy address
     *
     * @param proxyAddress String
     */
    public void setProxyAddress(String proxyAddress) {
        setConfig(TrackerConfigurationKeys.PROXY_ADDRESS, proxyAddress, null, true);
    }

    /**
     * Create a default listener
     *
     * @return tracker listener which log in console
     */
    public TrackerListener createDefaultTrackerListener() {
        return new TrackerListener() {
            @Override
            public void trackerNeedsFirstLaunchApproval(String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: First Launch \n\tMessage: " + message);
            }

            @Override
            public void buildDidEnd(HitStatus status, String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Building Hit \n\tStatus: " + status.toString() + "\n\tMessage: " + message);
            }

            @Override
            public void sendDidEnd(HitStatus status, String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Sending Hit \n\tStatus: " + status.toString() + "\n\tMessage: " + message);
            }

            @Override
            public void didCallPartner(String response) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Calling Partner \n\tResponse: " + response);
            }

            @Override
            public void warningDidOccur(String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Warning \n\tMessage: " + message);
            }

            @Override
            public void saveDidEnd(String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Saving Hit \n\tMessage: " + message);
            }

            @Override
            public void errorDidOccur(String message) {
                Log.d(ATInternet.TAG, "Debugging message: \n\tEvent: Error \n\tMessage: " + message);
            }
        };
    }

    /**
     * Set a new configuration
     *
     * @param conf              map that contains new keys/values
     * @param override          if true, old config fully cleared AND all default keys MUST be set
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     * @deprecated Since 2.3.5, override boolean parameter is useless, {@link #setConfig(HashMap, SetConfigCallback, boolean...)} instead.
     */
    @Deprecated
    public void setConfig(final HashMap<String, Object> conf, final boolean override, final SetConfigCallback setConfigCallback, boolean... sync) {
        if (sync.length == 1 && sync[0]) {
            if (override) {
                configuration.clear();
            }
            Set<String> keys = conf.keySet();
            for (String key : keys) {
                configuration.put(key, conf.get(key));
            }
            refreshConfigurationDependencies();
        } else {
            TrackerQueue.getInstance().put(new Runnable() {
                @Override
                public void run() {
                    if (override) {
                        configuration.clear();
                    }
                    Set<String> keys = conf.keySet();
                    for (String key : keys) {
                        configuration.put(key, conf.get(key));
                    }
                    refreshConfigurationDependencies();
                    if (setConfigCallback != null) {
                        setConfigCallback.setConfigEnd();
                    }
                }
            });
        }
    }

    /**
     * Set a new configuration
     *
     * @param conf              map that contains new keys/values
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setConfig(final HashMap<String, Object> conf, final SetConfigCallback setConfigCallback, boolean... sync) {
        setConfig(conf, false, setConfigCallback, sync);
    }

    /**
     * Set an only one new key/value pair
     *
     * @param key               /
     * @param value             /
     * @param setConfigCallback Callback called when the operation has been done
     * @param sync              (optional) perform the operation synchronously (default: false)
     */
    public void setConfig(final String key, final Object value, final SetConfigCallback setConfigCallback, boolean... sync) {
        if (sync.length == 1 && sync[0]) {
            configuration.put(key, value);
            refreshConfigurationDependencies();
        } else {
            TrackerQueue.getInstance().put(new Runnable() {
                @Override
                public void run() {
                    configuration.put(key, value);
                    refreshConfigurationDependencies();
                    if (setConfigCallback != null) {
                        setConfigCallback.setConfigEnd();
                    }
                }
            });
        }
    }

    /**
     * Set a new listener
     *
     * @param trackerListener /
     * @return Tracker instance
     */
    public Tracker setListener(TrackerListener trackerListener) {
        this.listener = trackerListener;
        if (getPreferences().getBoolean(LifeCycle.FIRST_SESSION, false)) {
            listener.trackerNeedsFirstLaunchApproval("Tracker First Launch");
        }
        return this;
    }

    /**
     * Set a default tracker listener (see createDefaultTrackerListener method)
     *
     * @return Tracker instance
     */
    public Tracker setDefaultListener() {
        this.listener = createDefaultTrackerListener();
        if (getPreferences().getBoolean(LifeCycle.FIRST_SESSION, false)) {
            listener.trackerNeedsFirstLaunchApproval("Tracker First Launch");
        }
        return this;
    }

    /**
     * Disable user identification
     *
     * @param enabled /
     * @deprecated please use the same method in ATInternet class instead
     */
    @Deprecated
    public static void optOut(final boolean enabled) {
        TrackerQueue.getInstance().put(new Runnable() {
            @Override
            public void run() {
                TechnicalContext.optOut(appContext.get(), enabled);
            }
        });
    }

    /**
     * Get "optOut" value
     *
     * @return true if "optOut" is enabled
     * @deprecated please use the same method in ATInternet class instead
     */
    @Deprecated
    public static boolean optOutEnabled() {
        return TechnicalContext.optOutEnabled(appContext.get());
    }

    /**
     * Disable user identification
     *
     * @param enabled /
     * @deprecated please use {@link #optOut(boolean)} instead
     */
    @Deprecated
    public static void doNotTrack(final boolean enabled) {
        TrackerQueue.getInstance().put(new Runnable() {
            @Override
            public void run() {
                TechnicalContext.optOut(appContext.get(), enabled);
            }
        });
    }

    /**
     * Get "optOut" value
     *
     * @return true if "optOut" is enabled
     * @deprecated please use {@link #optOutEnabled()} instead
     */
    @Deprecated
    public static boolean doNotTrackEnabled() {
        return TechnicalContext.optOutEnabled(appContext.get());
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value integer value
     * @return Tracker instance
     */
    public Tracker setParam(String key, int value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   integer value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, int value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value float value
     * @return Tracker instance
     */
    public Tracker setParam(String key, float value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   float value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, float value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value double value
     * @return Tracker instance
     */
    public Tracker setParam(String key, double value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   double value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, double value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value boolean value
     * @return Tracker instance
     */
    public Tracker setParam(String key, boolean value) {
        return handleNotClosureStringParameterSetting(key, value);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   boolean value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, boolean value, ParamOption options) {
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value string value
     * @return Tracker instance
     */
    public Tracker setParam(String key, String value) {
        return setParam(key, value, new ParamOption());
    }

    /**
     * Add a property in the hit querystring
     *
     * @param key        property key
     * @param value      string value
     * @param persistent boolean option
     * @return Tracker instance
     */
    public Tracker setProp(String key, final String value, boolean persistent) {
        return setParam(key, new Closure() {
            @Override
            public String execute() {
                return value;
            }
        }, new ParamOption()
                .setEncode(true)
                .setPersistent(persistent)
                .setProperty(true));
    }

    /**
     * Add properties in the hit querystring
     *
     * @param props props map
     * @return Tracker instance
     */
    public Tracker setProps(Map<String, String> props, boolean persistent) {
        for (Map.Entry<String, String> entry : props.entrySet()) {
            setProp(entry.getKey(), entry.getValue(), persistent);
        }
        return this;
    }

    /**
     * Get a property
     *
     * @param key property key
     * @return param object
     */
    public Param getProp(String key) {
        Param prop = getParam(key);
        if (prop != null && prop.isProperty()) {
            return prop;
        }
        return null;
    }

    /**
     * Get all properties
     *
     * @return List properties
     */
    public List<Param> getProps() {
        List<Param> params = getParams();
        List<Param> properties = new ArrayList<>();
        for (Param p : params) {
            if (p.isProperty()) {
                properties.add(p);
            }
        }
        return properties;
    }

    /**
     * remove property from the hit
     *
     * @param key property key
     */
    public void delProp(String key) {
        Param prop = getProp(key);
        if (prop != null) {
            unsetParam(prop.getKey());
        }
    }

    /**
     * remove properties from the hit
     */
    public void delProps() {
        List<String> keys = new ArrayList<>();
        keys.addAll(buffer.getVolatileParams().keySet());
        keys.addAll(buffer.getPersistentParams().keySet());
        for (String key : keys) {
            delProp(key);
        }
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   string value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, final String value, ParamOption options) {
        if (options.getType() != ParamOption.Type.JSON && Tool.isJSON(value)) {
            options.setType(ParamOption.Type.JSON);
        } else if (options.getType() != ParamOption.Type.ARRAY && Tool.isArray(value)) {
            options.setType(ParamOption.Type.ARRAY);
        }
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value list value
     * @return Tracker instance
     */
    public Tracker setParam(String key, List value) {
        return setParam(key, value, new ParamOption());
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   list value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, List value, ParamOption options) {
        options.setType(ParamOption.Type.ARRAY);
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value object array value
     * @return Tracker instance
     */
    public Tracker setParam(String key, Object[] value) {
        return setParam(key, value, new ParamOption());
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   object array value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, Object[] value, ParamOption options) {
        options.setType(ParamOption.Type.ARRAY);
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key   parameter key
     * @param value map value
     * @return Tracker instance
     */
    public Tracker setParam(String key, Map value) {
        return setParam(key, value, new ParamOption());
    }

    /**
     * Add a parameter in the hit querystring
     *
     * @param key     parameter key
     * @param value   map value
     * @param options parameter options
     * @return Tracker instance
     */
    public Tracker setParam(String key, Map value, ParamOption options) {
        options.setType(ParamOption.Type.JSON);
        return handleNotClosureStringParameterSetting(key, value, options);
    }

    /**
     * Remove a parameter from the hit querystring
     *
     * @param key parameter key to remove
     */
    public void unsetParam(String key) {
        buffer.getVolatileParams().remove(key);
        buffer.getPersistentParams().remove(key);
    }

    /**
     * Reset Screen context to prevent bad link between screen and gesture
     */
    public void resetScreenContext() {
        TechnicalContext.resetScreenContext();
    }

    /**
     * Sends all tracking objects added
     */
    public void dispatch() {
        if (businessObjects.size() == 0) {
            dispatcher.dispatch();
            return;
        }
        ArrayList<BusinessObject> onAppAds = new ArrayList<>();
        ArrayList<BusinessObject> customObjs = new ArrayList<>();

        ArrayList<BusinessObject> objects = new ArrayList<>();
        objects.addAll(businessObjects.values());

        ArrayList<BusinessObject> screenObjects = new ArrayList<>();
        ArrayList<BusinessObject> salesTrackerObjects = new ArrayList<>();
        ArrayList<BusinessObject> internalSearchObjects = new ArrayList<>();
        ArrayList<BusinessObject> productsObjects = new ArrayList<>();

        for (BusinessObject businessObject : objects) {

            if (!(businessObject instanceof Product)) {
                dispatchObjects(productsObjects, customObjs);
            }

            // Dispatch onAppAds before sending other object
            if (!isScreenCompatible(businessObject) || (businessObject instanceof OnAppAd && ((OnAppAd) businessObject).getAction() == OnAppAd.Action.Touch)) {
                dispatchObjects(onAppAds, customObjs);
            }

            if (businessObject instanceof OnAppAd) {
                OnAppAd ad = (OnAppAd) businessObject;
                if (ad.getAction() == OnAppAd.Action.View) {
                    onAppAds.add(ad);
                } else {
                    customObjs.add(businessObject);
                    dispatcher.dispatch((BusinessObject[]) customObjs.toArray(new BusinessObject[customObjs.size()]));
                    customObjs.clear();
                }
            } else if (businessObject instanceof CustomObject || businessObject instanceof NuggAd) {
                customObjs.add(businessObject);
            } else if (businessObject instanceof ScreenInfo) {
                screenObjects.add(businessObject);
            } else if (businessObject instanceof InternalSearch) {
                internalSearchObjects.add(businessObject);
            } else if (businessObject instanceof Product) {
                productsObjects.add(businessObject);
            } else if (businessObject instanceof Order || businessObject instanceof Cart) {
                salesTrackerObjects.add(businessObject);
            } else if (businessObject instanceof AbstractScreen) {
                onAppAds.addAll(customObjs);
                onAppAds.addAll(screenObjects);
                onAppAds.addAll(internalSearchObjects);

                //Sales tracker
                ArrayList<BusinessObject> ordersObjects = new ArrayList<>();
                Cart crt = null;

                for (BusinessObject obj : salesTrackerObjects) {
                    if (obj instanceof Cart) {
                        crt = (Cart) obj;
                    } else {
                        ordersObjects.add(obj);
                    }
                }

                if (crt != null && (((AbstractScreen) businessObject).isBasketScreen() || !ordersObjects.isEmpty())) {
                    onAppAds.add(crt);
                }

                onAppAds.addAll(ordersObjects);
                onAppAds.add(businessObject);
                dispatcher.dispatch((BusinessObject[]) onAppAds.toArray(new BusinessObject[onAppAds.size()]));

                screenObjects.clear();
                salesTrackerObjects.clear();
                internalSearchObjects.clear();
                onAppAds.clear();
                customObjs.clear();
            } else {
                if (businessObject instanceof Gesture && ((Gesture) businessObject).getAction() == Gesture.Action.InternalSearch) {
                    onAppAds.addAll(internalSearchObjects);
                    internalSearchObjects.clear();
                }
                onAppAds.addAll(customObjs);
                onAppAds.add(businessObject);
                dispatcher.dispatch((BusinessObject[]) onAppAds.toArray(new BusinessObject[onAppAds.size()]));

                onAppAds.clear();
                customObjs.clear();
            }
        }

        dispatchObjects(onAppAds, customObjs);
        dispatchObjects(productsObjects, customObjs);

        if (customObjs.isEmpty() && screenObjects.isEmpty() && internalSearchObjects.isEmpty() && salesTrackerObjects.isEmpty()) {
            return;
        }

        customObjs.addAll(screenObjects);
        customObjs.addAll(internalSearchObjects);
        customObjs.addAll(salesTrackerObjects);
        dispatcher.dispatch((BusinessObject[]) customObjs.toArray(new BusinessObject[customObjs.size()]));

        customObjs.clear();
        screenObjects.clear();
        internalSearchObjects.clear();
        salesTrackerObjects.clear();
    }

    private boolean isScreenCompatible(BusinessObject businessObject) {
        return businessObject instanceof OnAppAd || businessObject instanceof ScreenInfo || businessObject instanceof AbstractScreen || businessObject instanceof InternalSearch || businessObject instanceof Cart || businessObject instanceof Order;
    }

    /***
     * Get lifecycle metrics computed by SDK
     * @return Map
     */
    public Map<String, Object> getLifecycleMetrics() {
        return LifeCycle.getMetricsMap(getPreferences());
    }

    /***
     * Get crash informations saved
     * @return Map
     */
    public Map<String, String> getCrashInformation() {
        return CrashDetectionHandler.getCrashInfo(getPreferences());
    }

    /***
     * Get SDK version
     * @return String
     */
    public String getSdkVersion() {
        return TechnicalContext.VTAG.execute();
    }

    /**
     * Set a custom application version
     *
     * @param value new application version value
     */
    Tracker setApplicationVersion(String value) {
        ParamOption po = new ParamOption().setPersistent(true);
        if (TextUtils.isEmpty(value)) {
            handleNotClosureStringParameterSetting("apvr", String.format("[%s]", TechnicalContext.getApplicationVersion()), po);
        } else {
            handleNotClosureStringParameterSetting("apvr", String.format("[%s]", value), po);
        }
        applicationVersion = value;
        return this;
    }

    /***
     * Override user agent for instance
     * @param ua new user agent
     * @return Tracker instance
     */
    Tracker setUserAgent(String ua) {
        userAgent = ua;
        return this;
    }

    /***
     * Get current tracker user agent
     * @return Tracker user agent
     */
    String getUserAgent() {
        return userAgent;
    }
}
